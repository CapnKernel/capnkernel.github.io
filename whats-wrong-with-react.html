<!DOCTYPE html><html lang="en-au"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>What&#x27;s wrong with React? - Mitch&#x27;s Notes</title><meta name="description" content="One way to write web-based client-server software is to run client software in the browser, which talks to back-end software via a RESTful interface: The client sends in HTTP form data, and the server responds with JSON. React is super-popular for writing the front-end part&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://capnkernel.github.io/whats-wrong-with-react.html"><link rel="alternate" type="application/atom+xml" href="https://capnkernel.github.io/feed.xml" title="Mitch&#x27;s Notes - RSS"><link rel="alternate" type="application/json" href="https://capnkernel.github.io/feed.json" title="Mitch&#x27;s Notes - JSON"><meta property="og:title" content="What's wrong with React?"><meta property="og:site_name" content="Mitch's Notes"><meta property="og:description" content="One way to write web-based client-server software is to run client software in the browser, which talks to back-end software via a RESTful interface: The client sends in HTTP form data, and the server responds with JSON. React is super-popular for writing the front-end part&hellip;"><meta property="og:url" content="https://capnkernel.github.io/whats-wrong-with-react.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://capnkernel.github.io/assets/css/style.css?v=495c66618552c9dc0a5b4b1c0855e010"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://capnkernel.github.io/whats-wrong-with-react.html"},"headline":"What's wrong with React?","datePublished":"2025-10-18T11:00+11:00","dateModified":"2025-10-18T11:52+11:00","description":"One way to write web-based client-server software is to run client software in the browser, which talks to back-end software via a RESTful interface: The client sends in HTTP form data, and the server responds with JSON. React is super-popular for writing the front-end part&hellip;","author":{"@type":"Person","name":"Mitch","url":"https://capnkernel.github.io/authors/mitch/"},"publisher":{"@type":"Organization","name":"Mitch"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://capnkernel.github.io/">Mitch&#x27;s Notes</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>What&#x27;s wrong with React?</h1><div class="feed__meta content__meta"><a href="https://capnkernel.github.io/authors/mitch/" class="feed__author">Mitch</a> <time datetime="2025-10-18T11:00" class="feed__date">October 18, 2025</time></div></div></header></div><div class="entry-wrapper content__entry"><p>One way to write web-based client-server software is to run client software in the browser, which talks to back-end software via a RESTful interface: The client sends in HTTP form data, and the server responds with JSON. React is super-popular for writing the front-end part of this, but I’ve always been so grossed out by what’s actually required to write stuff in React that I refuse to touch it. Yet React’s become a sacred cow that can’t be questioned. Well I’m here to question it.</p><p>First, the idea of the Virtual DOM. We’ve been sold on the necessity of continually running a reconciliation process between it and the reality of the browser, and we pat ourselves on the back about how cool this diffing algorithm is, while we lose sight of how fundamentally inefficient it is to build the whole UI tree in memory from scratch on every state change, only to throw most of it away. This process is so inefficient that we’ve had to invent the “Fiber” architecture to stop the browser’s main thread from choking. Good job.</p><p>JSX and its inline HTML requires a compile step, which means the extra complexity of maintaining a toolchain and doing builds. Who hasn’t lost days tracking down problems that wouldn’t have occurred if there were no build step?</p><p>One thing Django has over (traditional) PHP is the separation of logic over presentation. With JSX, logic and presentation are mixed in together, making it harder to test and reason about both. The HTML in React components is inevitably tied to the HTML on the web pages that’ll use it because of things like styling and element ids, so while modularisation is possible, reuse isn’t that practical.</p><p>The Hooks API, which was supposed to make stateful logic simpler, is a minefield of unintuitive rules and implicit dependencies. The infamous “stale closure” problem is not a rare edge case but a central, recurring theme that you will get. Having a function that captures a snapshot of state creates a temporal dissonance where your code is never quite running in the present. Managing these ephemeral, almost quantum-mechanical state variables requires a linter with a rulebook of its own, a testament to an API so fragile it cannot be trusted to be used correctly by default. What if we didn’t have to capture this state in the first place?</p><p>React’s minimalism is a mirage. By intentionally washing its hands of core application needs like routing, data fetching, and state management, it’s spawned a sprawling, unstable ecosystem of third-party libraries, each with its own philosophy, lifecycle, and inevitable deprecation schedule, to fill the gaps (give me Django’s batteries-included approach). A React project in 2025 is less a cohesive application and more a delicate tapestry of <code>useEffect</code>, <code>useState</code>, Context, Redux, TanStack Query, and whatever router we’re using this week , all held together by the hope that their intricate interactions don’t produce an inscrutable bug. The problem React tried to solve was writing scalable UIs, but delivering the solution the React way requires a toolchain so complex and brittle that the original problem of the DOM feels simple by comparison. It is a <a href="https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/">fractal of bad design</a>: from the confusing rules of Hooks, to the wasteful reconciliation process, up to the chaotic ecosystem it has fostered, every level reveals a new layer of accidental complexity.</p><p>In terms of a fractal assembly of bad ideas now too deeply embedded in the ‘net to be fixed, see also JavaScript. Don’t get me started, really. Just because you can doesn’t mean it’s a good idea. For example, the whole “promise” thing and how work is scheduled in JS is someone’s Ph.D thesis let loose that shouldn’t have seen the light of day, because it produces code that is so crufted up with the promise crap, that it drowns out the code you’re writing to solve a problem. And that’s just one of the problems it has.</p><p>Python’s as lovely as it is because it had the good taste to be crafted by a first-rate computer scientist, not software engineers. I’ve heard the same of go and rust; I look forward to learning more about them.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on October 18, 2025</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://capnkernel.github.io/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://capnkernel.github.io/authors/mitch/" rel="author">Mitch</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://capnkernel.github.io/inventree-100-install.html" class="content__nav-link" rel="prev"><div><span>Previous</span> Inventree 1.0.x install</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://capnkernel.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://capnkernel.github.io/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>